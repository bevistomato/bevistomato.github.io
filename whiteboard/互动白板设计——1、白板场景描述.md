# 互动白板设计
## 背景描述

最近在互联网在线教育越来越火，但是目前在线教育的课堂和线下课堂还有具有相当的差别，习惯了传统课堂教学的学生和家长，对于在线课堂的接受仍然较低。如何增大受众的接收度，扩展在线培训市场，成为各大公司都在想尽办法解决的重要问题之一。


常理上来说，在线课堂越像线下课堂，大众对在线课堂的接受越容易。目前模拟线下课堂，主要手段包括：互动视频、互动白板或者两者相结合这三类。互动视频的具有带宽占用大，硬件要求高等问题，部署的成本较高，使得互动白板成为模拟在线课堂的最受欢迎的组件之一。所谓互动白板就是一个支持多人同时图画的绘图板，参与绘图的人实时可以看到其他人在白板上绘画的内容，并可以在其基础上进行删改。

## 场景描述
互动白板用于在线课堂是为了仿真线下教育场景，如何才能让尽量模拟的逼真呢？首先需要分析一下线下最长出现的场景：
* 线下课堂由一个老师和若干个学生组成。根据课堂学生人数的多少，决定了老师是使用黑板站着教学或使用白纸坐着教学（为了简便，认为老师都在写黑板）。
* 课堂上的主要时间，都是老师在讲授知识，学生在听课。讲授的过程中，老师会在黑板上书写知识点。
* 老师和学生都有讲义，老师还可能会使用投影、电脑等数字手段在黑板上直接显示讲义并且在讲义上书写笔记。
* 期间可能会穿插老师在黑板上出题，学生各自在草稿纸上作答，期间老师巡堂抽查学生的作答情况。
* 老师还可能会让其中一个学生，直接在黑板上写，之后进行评讲。

从以上传统教学场景中可以发现，整个教学过程都是围绕着黑板和草稿纸进行。因此，想要模拟得逼真，就要让互动白板能够实现传统课堂中黑板和草稿纸的全部功能。具体来说：
* 在线课堂上一般除了1个老师之外，还包括若干个学生，老师和学生们都坐在一台计算机前。
* 模拟一块黑板，老师在一块上面写板书或笔记，学生们在听课看老师写笔记。
* 为每个学生模拟一张草稿纸，随堂作业，学生可以在上面书写。老师可以看到学生们各自的做题内容，但是此时学生之间不能相互看到对方的作答，以防止抄袭。
* 在评讲阶段，草稿纸可以被其他学生看到。
* 模拟的黑板和草稿纸，又要具备显示电子讲义的功能。

## 问题抽象
从上述具体使用场景可以抽象出互动白板的抽象功能，因为老师和学生使用互动白板的方式差别不大，所以可以将两者统一成用户。因此有如下假设：

**基本假设：互动白板上有N个使用者，和M页的课堂讲义，则有以下功能：**
* 每个使用者拥有M块白板，换言之，N个使用者，共有N x M块白板。其中老师的那M块用作黑板，每个学生的M块用作草稿纸。
* M块白板分别可以设定一个背景。老师的第i块白板的背景和学生的第i块白板的背景一致。
* 每个使用者都可以在任何1块白板上拥有读权限、写权限和更改背景权限。没有读权限则不可能看到白板的内容，没有写权限则不可能编辑白板内容，没有变换背景权限则不可能更改白版的背景图片。


满足基本假设之上的互动白板已经是可以满足线上教学场景的软件了。但是，只有最基本假设的软件，使用起来并不便捷。例如：学生不听话（不小心）取消掉了老师的读写权限，就会导致课堂不能正常进行的问题。为了能够正常的实用软件，还需要对使用者做身份假设以及使用场景假设：

**身份假设：老师身份和学生身份**
* 老师拥有所有白板的读/写/背景权限，予夺学生读写权限的权限。
* 学生仅拥有部分白板的读写权限。

**场景假设：授课场景和做题场景**

在身份假设和场景假设下，就可对使用者作进一步规范：

1、每个白板的读写规范：


读写 | 老师 | 学生
-------- | ----- | ----
授课场景 | 所有白板自由读写 | 只可读老师正在读写的白板
做题场景 | 所有白板自由读写 | 学生所拥有白板自由读写（学生可以随意翻页） 



2、上课时，对可能出现的缩放操作规范：


缩放 | 老师 | 学生
-------- | ----- | ----
授课场景 | 自由缩放 | 跟随老师缩放
做题场景 | 自由缩放 | 自由缩放



3、背景讲义加载规范：


背景 | 老师 | 学生
-------- | ----- | ----
授课场景 | 删增 | 跟随老师变化
做题场景 | 删增 | 跟随老师变化


## 客户端之间事件触发（由服务器转发）
从规范的场景中可以看出，老师端的一些变化要在学生端出现，因此需要规定一些事件，是的学生端可以在监听到事件之后做出相应的改变

**书写**

WRITE_POINT(0x00000001) X坐标(Int32) Y坐标(Int32) P压力(float)

**擦除**

ERASER_POINT(0x00000002) X坐标(Int32) Y坐标(Int32)

**笔状态变化**

CHNAGE_PEN(0x00000003) PEN_ID(BYTE) 笔粗细(BYTE)

**添加白板**

UPDATE_BOARD(0x00000003) BOARD_ID(BYTE) URL_LEN(Int32) BOARD_URL(BYTE[])

客户端像云中上传背景图片之后，向其他客户端转发地址
BOARD_ID如果存在就是替换，不存在就是添加

**缩放**

ZOOM_BOARD (0x00000003) X坐标(float) Y坐标(float)

**白板滑动**

MOVE_BOARD (0x00000004) X坐标(float) Y坐标(float)

**更换白板**

CHANGE_BOARD (0x00000005) USER_ID(Int32) BOARD_ID(Int32)

**更换场景**

CHANGE_MODE (0x00000006) 授课场景(0x00000000) / 做题场景(0x00000001)

## 客户端和服务器端之间事件触发

客户端之间的数据交流需要通过服务器中转完成，因此，必须要有相应的事件来和服务器通信来建立链接和断开连接。此外，网络场景下，容易因为死机，掉线等等问题不得不重启软件的问题。这个时候就需要能从服务器端重新同步状态，此时服务器需要监听一些事件并作出相应反馈：

**创建教室**

CREATE_ROOM(0x00000007) 名字长度STR_LEN(8bit) 教室名称STR

CREATE_ROOM_RESULT(0x00000008) ROOM_ID(Int64)

客户端在发送CREATE_ROOM和接收到CREATE_ROOM_RESULT之间不相应其他消息

ROOM_ID 负数表示发生错误

**进入教室**

JOIN_ROOM(0x00000009) ROOM_ID(Int64)

JOIN_ROOM_RESULT(0x0000000A) RESULT(Int32)

客户端在发送JOIN_ROOM和接收到JOIN_ROOM_RESULT之间不相应其他消息


RESULT 0表示进入成功，负数表示进入失败

**同步数据**

SYNC_STATE(0x0000000B) 

仅有客户端发送

客户端在发送该指令后，重置所有状态

服务器端接收该指令后，充值客户端状态，开始重放数据（包括状态）



**心跳数据**
HEART_TICK(0x0000000C)

仅有客户端发送
心跳数据，服务器每30秒轮询一次，
客户端，每15秒发送一次心跳


## 状态自动机


## 传输数据优化

从计算机中采集笔画数据可知，一笔画大约消耗30个点，如果每个点按照cmd<byte> uid<byte> X<double> Y<double> P<float>来发送的话，每一个点需要消耗 22个byte，一笔画则需要消耗660个byte了。如果一个字平均10笔画，一节课由7个人90分钟内共产生20000个字的话，就需要产生660 * 10 * 20000 = 132000000 byte = 132000 kB = 132MB的数据。此数据规模缓存在服务器并不会对服务器产生多大压力，但是服务器除了缓存者132M的数据之外，还需要将数据转发至课堂中的每一个用户中。因此转发流量是132 * 6 = 792MB（除去发送者），所需要的平均带宽是792 * 8 / 90 / 60 = 1.18Mbps，这个平均带宽就比较大了，一台云服务器如果开启5M带宽，那么同时并发课堂数据也只能是4个。因此，必须要优化传输的数据。

### 数据点优化

** 减少每个点的数据量 **

在实际使用中，我们可以规定白板的宽度，从实验中可以获知，当缩放比例限制为10倍时，Win下产生的点阵数据，和白板宽度相同。由于目前计算机屏幕普遍分辨率在1080P水平上，所以我们限制白板宽宽度和高度最大值为4096px。从实验中我们发现，直接存储整数会导致复原的笔画和原笔画差距较大，为此还需要存储一定位数的小数，经过对比，发现只需要存储1位小数，就可以完美还原笔画。为此，要存储的数据范围是[0, 40960]中的任何一个数字，需要空间是16b。

Win下压感的数据虽然是一个浮点数，但是从实验中，我们发现压感的数值长期在数个常见的数值中变换。因此，我们大胆假设，压感值可以还原成一个分母不大的分数，且分母的数值不变。从目前市场上可用的压感笔推断，分母因该是，256，512，1024，2048，4096这几个数字中的一个。进过大量数据拟合，我们发现分母是1024，所以压感的数据我们只需要记录分子就可以了。经过实际测试，书写中压感的变化并不明显，即使将数据范围压缩至[0, 256]也看不出变化。所以最后发送的数据范围是[0, 256]，只需要8b。整个点的数值只需要16 + 16 + 8 = 40bit，可以存储在5byte中。

** 将多个点组合成数据帧 **

一个笔画平均消耗30个点，如果每个点单独传输，每一个点都需要发送cmd和uid这两个参数。如果可以合并一些点统一发送，就可以省略掉重复发送cmd和uid进入的流量开销。因为人眼的技能构造，视频传输的帧率都在30帧左右，也有最低24帧的视频，就可以保证观看的流畅性，所以我们发送数据的频率也可以设定在30fps。只要在1/30秒内收到的点数据，都缓存起来统一发送。

由于一条命令内包含多个点，我们就需要告诉解析数据点的程序，当前它接收的命令内包含多少个点数据。我们需要多大的空间来记录点的数目呢？从经验来看，我们在1秒内也写不了多少笔画，所以只要1byte，就一定足够记录包含的点数目了。


** 更进一步的压缩 **

笔画具有连续性，所以当知道第一个点的坐标后，就可以知道第二个点的坐标就在它的旁边。因此，我们在发送命令的时候，只需要第一个命令发送完整的坐标数据，从第二个点开始，只要发送相邻两个点的坐标差值就行了。那么，坐标差值的范围是多少呢？经过我们的实验，采样后相邻两个点的差值在100以内，所以我们只需要8b就足够存储了。

最终我们采用如下方式记录一个点。

WRITE_POINT<8b> uid<8b> number<8b> X<16b> Y<16b> P<8b> ... X<8b> Y<8> P<8b>




同理，删除情况下，由于点不需要特别精确，直接存储整数就可以，范围是[0, 17065]，需要存储开销是15b,

ERASER_POINT<8b> uid<8b> X<16b> Y<16b>


### 滑动缩放数据优化

**发送频次优化**

用户产生一个一个滑动，计算机会连续采样多次，如果将这些数据都发送给服务器，无疑会产生大量的带宽开销。分析可知，只需要将最终的位置和缩放比例发送给其他用户，就可以成功同步其他用户的行为。

为此，可以在滑动开始时启动一个时钟，时钟检测滑动数据的变化情况，当数据不再变化才将最终的数据发送出去。

**数据存储优化**

一次滑动缩放，会产生一组数据X<double> Y<double> Z<float>。其中，X和Y在10倍缩放条件下，数据范围和笔记数据点的数据范围不一样，是背景图片大小的10倍。当我们限定宽是1920px，高是17065px时，可以直接计算出，X和Y的数据范围是[0, 170650]。滑动并不需要太精确，放大后几个甚至几十个px的差距肉眼几乎都看不处，所以可以将数据范围压缩至[0, 1707]内的一个整数，存储开销只需要11b。当用户接收到滑动数据后，再将数值乘以10之后，再用来作为滑动的坐标，就可以基本同步还原滑动操作了。
  
缩放比例则是粒度是0.01的数据，整数部分最大是10，所以只需要将缩放比例乘以100再取整，就可用数据范围在[0, 1000]的一个整数来表示缩放比例了,只需要10b就可存储。当用户接收到缩放比例的整数后，除以100就是真正的缩放比例了。

最终，滑动缩放，产生的存储开销是

CHANGE_VIEW<8b> uid<8b> X<11b> Y<11b> Z<10b> （由ZOOM BOARD和MOVE BOARD合并后命令）




